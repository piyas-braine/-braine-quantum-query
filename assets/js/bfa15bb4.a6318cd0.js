"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[594],{6230(e,n,t){t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"guides/infinite-queries","title":"Infinite Queries","description":"Ideal for \\"Load More\\" buttons or Infinite Scroll UIs where data is fetched in pages.","source":"@site/docs/guides/infinite-queries.md","sourceDirName":"guides","slug":"/guides/infinite-queries","permalink":"/-braine-quantum-query/docs/guides/infinite-queries","draft":false,"unlisted":false,"editUrl":"https://github.com/piyas-braine/-braine-quantum-query/tree/main/website/docs/guides/infinite-queries.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Fine-Grained Reactivity (The \\"Ferrari Engine\\")","permalink":"/-braine-quantum-query/docs/guides/fine-grained-reactivity"},"next":{"title":"Mutations","permalink":"/-braine-quantum-query/docs/guides/mutations"}}');var a=t(4848),s=t(8453);const r={},o="Infinite Queries",u={},c=[{value:"Basic Usage",id:"basic-usage",level:2},{value:"Bi-Directional Infinite Scroll",id:"bi-directional-infinite-scroll",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"infinite-queries",children:"Infinite Queries"})}),"\n",(0,a.jsx)(n.p,{children:'Ideal for "Load More" buttons or Infinite Scroll UIs where data is fetched in pages.'}),"\n",(0,a.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,a.jsx)(n.p,{children:"`useInfiniteQuery` works similarly to `useQuery` but introduces the concept of pages."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"import { useInfiniteQuery } from '@braine/quantum-query';\n\nfunction LoadMorePosts() {\n  const { \n    data, \n    fetchNextPage, \n    hasNextPage, \n    isFetchingNextPage \n  } = useInfiniteQuery({\n    queryKey: ['posts'],\n    // Page param is passed automatically\n    queryFn: ({ pageParam = 1 }) => fetch(\\`/api/posts?page=\\${pageParam}\\`).then(r => r.json()),\n    \n    // Determine the next page param based on the last page response\n    getNextPageParam: (lastPage, allPages) => {\n      return lastPage.nextCursor; \n    }\n  });\n\n  return (\n    <>\n      {/* Flatten pages into a single list */}\n      {data?.pages.map((page, i) => (\n        <React.Fragment key={i}>\n          {page.items.map(post => <PostCard key={post.id} post={post} />)}\n        </React.Fragment>\n      ))}\n\n      <button \n        onClick={() => fetchNextPage()}\n        disabled={!hasNextPage || isFetchingNextPage}\n      >\n        {isFetchingNextPage ? 'Loading more...' : hasNextPage ? 'Load More' : 'Nothing more to load'}\n      </button>\n    </>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"bi-directional-infinite-scroll",children:"Bi-Directional Infinite Scroll"}),"\n",(0,a.jsx)(n.p,{children:"Quantum Query supports fetching previous pages too, perfect for chat applications."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"const chatQuery = useInfiniteQuery({\n  queryKey: ['chat', roomId],\n  queryFn: fetchChatMessages,\n  // Cursor for fetching OLDER messages\n  getPreviousPageParam: (firstPage) => firstPage.prevCursor, \n  // Cursor for fetching NEWER messages\n  getNextPageParam: (lastPage) => lastPage.nextCursor, \n});\n"})})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453(e,n,t){t.d(n,{R:()=>r,x:()=>o});var i=t(6540);const a={},s=i.createContext(a);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);