"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[131],{8264(e,t,n){n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"guides/tag-invalidation","title":"Tag-Based Invalidation","description":"Most query libraries use fuzzy string matching (prefix matching) to invalidate queries. While simple, this becomes a performance bottleneck in large applications.","source":"@site/docs/guides/tag-invalidation.md","sourceDirName":"guides","slug":"/guides/tag-invalidation","permalink":"/-braine-quantum-query/docs/guides/tag-invalidation","draft":false,"unlisted":false,"editUrl":"https://github.com/piyas-braine/-braine-quantum-query/tree/main/website/docs/guides/tag-invalidation.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Suspense","permalink":"/-braine-quantum-query/docs/guides/suspense"},"next":{"title":"Schema-First Validation","permalink":"/-braine-quantum-query/docs/guides/validation"}}');var s=n(4848),a=n(8453);const l={},r="Tag-Based Invalidation",d={},o=[{value:"The Problem with Prefix Matching",id:"the-problem-with-prefix-matching",level:2},{value:"The Quantum Solution: Tag Indexing",id:"the-quantum-solution-tag-indexing",level:2},{value:"1. Assign Tags to Queries",id:"1-assign-tags-to-queries",level:3},{value:"2. Invalidate by Tag",id:"2-invalidate-by-tag",level:3},{value:"When to use Tags vs. Keys?",id:"when-to-use-tags-vs-keys",level:2}];function c(e){const t={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"tag-based-invalidation",children:"Tag-Based Invalidation"})}),"\n",(0,s.jsx)(t.p,{children:"Most query libraries use fuzzy string matching (prefix matching) to invalidate queries. While simple, this becomes a performance bottleneck in large applications."}),"\n",(0,s.jsxs)(t.p,{children:["Quantum Query introduces ",(0,s.jsx)(t.strong,{children:"O(1) Tag-Based Invalidation"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"the-problem-with-prefix-matching",children:"The Problem with Prefix Matching"}),"\n",(0,s.jsxs)(t.p,{children:['Imagine you have 1,000 queries for individual "Posts". To invalidate them all in TanStack Query, you might do ',(0,s.jsx)(t.code,{children:"queryClient.invalidateQueries(['posts'])"}),". The library must iterate through all 1,000 keys to find matches."]}),"\n",(0,s.jsx)(t.h2,{id:"the-quantum-solution-tag-indexing",children:"The Quantum Solution: Tag Indexing"}),"\n",(0,s.jsxs)(t.p,{children:["Quantum Query maintains an internal ",(0,s.jsx)(t.code,{children:"Map<string, Set<string>>"})," that indexes query keys by tags. This allows for constant-time lookups."]}),"\n",(0,s.jsx)(t.h3,{id:"1-assign-tags-to-queries",children:"1. Assign Tags to Queries"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"useQuery({\n  queryKey: ['post', id],\n  queryFn: () => fetchPost(id),\n  // Assign tags for grouping\n  tags: ['posts', `post-${id}`], \n});\n"})}),"\n",(0,s.jsx)(t.h3,{id:"2-invalidate-by-tag",children:"2. Invalidate by Tag"}),"\n",(0,s.jsx)(t.p,{children:"Instead of matching strings, you target the index directly."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"const client = useQueryClient();\n\nconst mutation = useMutation({\n  mutationFn: updatePost,\n  onSuccess: () => {\n    // Instant lookup. No iteration over the entire cache.\n    client.invalidateTags(['posts']); \n  }\n});\n"})}),"\n",(0,s.jsx)(t.h2,{id:"when-to-use-tags-vs-keys",children:"When to use Tags vs. Keys?"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Scenario"}),(0,s.jsx)(t.th,{style:{textAlign:"center"},children:"Use Keys"}),(0,s.jsx)(t.th,{style:{textAlign:"center"},children:"Use Tags"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Invalidating a single specific item"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"\u2705"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"-"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:'Invalidating a logical group (e.g., "all items in list")'}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"-"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"\u2705"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Complex overlapping groups"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"-"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"\u2705"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"High-frequency updates in large caches"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"-"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"\u2705"})]})]})]}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:'[!TIP]\nUse tags for "Mass Invalidation". Use keys for "Surgical Invalidation" of specific resources.'}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453(e,t,n){n.d(t,{R:()=>l,x:()=>r});var i=n(6540);const s={},a=i.createContext(s);function l(e){const t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);