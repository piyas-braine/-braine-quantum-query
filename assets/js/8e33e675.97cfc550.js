"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[677],{2987(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"recipes","title":"Recipes","description":"Authentication & Refresh Tokens","source":"@site/docs/recipes.md","sourceDirName":".","slug":"/recipes","permalink":"/-braine-quantum-query/recipes","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"API Reference","permalink":"/-braine-quantum-query/api"},"next":{"title":"Migrating from RTK Query","permalink":"/-braine-quantum-query/migration"}}');var o=t(4848),a=t(8453);const s={},i="Recipes",c={},l=[{value:"Authentication &amp; Refresh Tokens",id:"authentication--refresh-tokens",level:2},{value:"Optimistic Updates",id:"optimistic-updates",level:2},{value:"Infinite Scroll UI",id:"infinite-scroll-ui",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"recipes",children:"Recipes"})}),"\n",(0,o.jsx)(n.h2,{id:"authentication--refresh-tokens",children:"Authentication & Refresh Tokens"}),"\n",(0,o.jsx)(n.p,{children:"Configure global authentication handling, including automatic token injection and seamless refresh flows on 401 errors."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"import { createClient } from '@braine/quantum-query';\n\nconst client = createClient({\n  baseURL: 'https://api.example.com',\n  auth: {\n    // 1. Inject Token: Called before every request\n    getToken: async () => {\n      const token = localStorage.getItem('access_token');\n      return token; // Returns string or null\n    },\n\n    // 2. Refresh Logic: Called automatically on 401 response\n    onTokenExpired: async (client) => {\n      try {\n        const refreshToken = localStorage.getItem('refresh_token');\n        if (!refreshToken) return null;\n\n        // Perform refresh using a separate fetch or client instance\n        // to avoid infinite loops if the refresh endpoint also returns 401\n        const response = await fetch('https://api.example.com/auth/refresh', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ refreshToken })\n        });\n\n        if (!response.ok) throw new Error('Refresh failed');\n\n        const data = await response.json();\n        \n        // Save new tokens\n        localStorage.setItem('access_token', data.accessToken);\n        localStorage.setItem('refresh_token', data.refreshToken);\n\n        return data.accessToken; // Return new token to retry original request\n      } catch (err) {\n        // Refresh failed - clean up and redirect\n        localStorage.clear();\n        window.location.href = '/login';\n        return null;\n      }\n    },\n\n    // 3. Auth Failed: Called if onTokenExpired returns null or fails\n    onAuthFailed: () => {\n      window.location.href = '/login';\n    }\n  }\n});\n"})}),"\n",(0,o.jsx)(n.h2,{id:"optimistic-updates",children:"Optimistic Updates"}),"\n",(0,o.jsx)(n.p,{children:"Update the UI immediately before the network request finishes."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const { refetch } = useQuery({ queryKey: ['todos'], ... });\n\nconst handleAddTodo = async (newTodo) => {\n    // 1. Snapshot previous state (optional) or just write\n    queryCache.set(['todos'], (old) => [...old, newTodo]);\n\n    // 2. Perform mutation\n    await api.post('/todos', newTodo);\n\n    // 3. Revalidate to ensure server consistency\n    queryCache.invalidate(['todos']);\n};\n"})}),"\n",(0,o.jsx)(n.h2,{id:"infinite-scroll-ui",children:"Infinite Scroll UI"}),"\n",(0,o.jsx)(n.p,{children:'Simple implemention with a "Load More" button.'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"function PostList() {\n    const { data, fetchNextPage, hasNextPage } = useInfiniteQuery({\n        queryKey: ['posts'],\n        queryFn: ({ pageParam }) => fetchPosts(pageParam),\n        getNextPageParam: (lastPage) => lastPage.nextCursor\n    });\n\n    if (!data) return <Skeleton />;\n\n    return (\n        <div>\n            {data.pages.map(page => (\n                page.items.map(post => <Post key={post.id} data={post} />)\n            ))}\n            <button \n                onClick={() => fetchNextPage()} \n                disabled={!hasNextPage}\n            >\n                {hasNextPage ? 'Load More' : 'No More Data'}\n            </button>\n        </div>\n    );\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>s,x:()=>i});var r=t(6540);const o={},a=r.createContext(o);function s(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);