"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[986],{419(e,n,t){t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"guides/fine-grained-reactivity","title":"Fine-Grained Reactivity (The \\"Ferrari Engine\\")","description":"Quantum Query allows you to opt-out of React\'s top-down rendering model for data fetching. By using Signals, you can update individual DOM nodes or sub-components without re-rendering the parent component that initiated the fetch.","source":"@site/docs/guides/fine-grained-reactivity.md","sourceDirName":"guides","slug":"/guides/fine-grained-reactivity","permalink":"/-braine-quantum-query/docs/guides/fine-grained-reactivity","draft":false,"unlisted":false,"editUrl":"https://github.com/piyas-braine/-braine-quantum-query/tree/main/website/docs/guides/fine-grained-reactivity.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Smart Models","permalink":"/-braine-quantum-query/docs/concepts/smart-models"},"next":{"title":"Infinite Queries","permalink":"/-braine-quantum-query/docs/guides/infinite-queries"}}');var s=t(4848),i=t(8453);const a={},l='Fine-Grained Reactivity (The "Ferrari Engine")',o={},d=[{value:"The Problem: Render Tearing",id:"the-problem-render-tearing",level:2},{value:"The Solution: <code>useQuery$</code>",id:"the-solution-usequery",level:2},{value:"<code>QueryMatch</code> Component",id:"querymatch-component",level:2},{value:"When to use which?",id:"when-to-use-which",level:2},{value:"Best Practices",id:"best-practices",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"fine-grained-reactivity-the-ferrari-engine",children:'Fine-Grained Reactivity (The "Ferrari Engine")'})}),"\n",(0,s.jsxs)(n.p,{children:["Quantum Query allows you to opt-out of React's top-down rendering model for data fetching. By using ",(0,s.jsx)(n.strong,{children:"Signals"}),", you can update individual DOM nodes or sub-components without re-rendering the parent component that initiated the fetch."]}),"\n",(0,s.jsx)(n.p,{children:"This is the feature that makes Quantum Query theoretically superior to TanStack Query and standard React hooks."}),"\n",(0,s.jsx)(n.h2,{id:"the-problem-render-tearing",children:"The Problem: Render Tearing"}),"\n",(0,s.jsxs)(n.p,{children:["In standard libraries (like TanStack Query), ",(0,s.jsx)(n.code,{children:"useQuery"})," is a hook. When the data changes, the hook triggers a re-render of the component calling it."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// \ud83d\udc0c Standard Hook (TanStack Style)\nfunction UserProfile() {\n  console.log('Rendered!'); // Fires on 'pending' -> 'success' -> 'isFetching' ...\n  const { data } = useQuery({ queryKey: ['user'], queryFn: fetchUser });\n  \n  if (!data) return <Spinner />;\n  return <div>{data.name}</div>;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:'If you have a large dashboard with 50 queries, 50 re-renders happen. This causes "jank".'}),"\n",(0,s.jsxs)(n.h2,{id:"the-solution-usequery",children:["The Solution: ",(0,s.jsx)(n.code,{children:"useQuery$"})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"useQuery$"})," hook returns a ",(0,s.jsx)(n.strong,{children:"Signal"}),", not a value. A signal is a container for a value. Changing the value inside the signal does NOT trigger a React render of the component holding the signal."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// \u26a1\ufe0f Quantum Signal Hook\nimport { useQuery$, QueryMatch, SignalValue } from '@braine/quantum-query';\n\nfunction UserProfile() {\n  console.log('Rendered!'); // Fires ONCE. Never again.\n  const query$ = useQuery$({ queryKey: ['user'], queryFn: fetchUser });\n  \n  // The DataView component observes the signal directly.\n  return (\n    <QueryMatch signal={query$} selector={res => res.status}>\n        {status => (\n            status === 'success' ? \n            // SignalValue renders ONLY this text node when data changes\n            <SignalValue signal={query$}>{res => res.data.name}</SignalValue> \n            : <Spinner />\n        )}\n    </QueryMatch>\n  );\n}\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"querymatch-component",children:[(0,s.jsx)(n.code,{children:"QueryMatch"})," Component"]}),"\n",(0,s.jsxs)(n.p,{children:["To make this pattern ergonomic, we provide ",(0,s.jsx)(n.code,{children:"<QueryMatch>"}),". It acts like a logic gate that listens to the signal."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"<QueryMatch \n  signal={query$} \n  selector={result => result.status} // Select what you care about (e.g. status)\n>\n  {(status) => {\n    // This inner function runs only when 'status' changes.\n    if (status === 'pending') return <Skeleton />;\n    if (status === 'error') return <Error />;\n    return <DataView />;\n  }}\n</QueryMatch>\n"})}),"\n",(0,s.jsx)(n.h2,{id:"when-to-use-which",children:"When to use which?"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Feature"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"useQuery"})}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"useQuery$"})})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.strong,{children:"Returns"})}),(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["Value (",(0,s.jsx)(n.code,{children:"TData"}),")"]}),(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["Signal (",(0,s.jsx)(n.code,{children:"Signal<TData>"}),")"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.strong,{children:"Re-renders Parent?"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Yes"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.strong,{children:"No"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.strong,{children:"Usage"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"General Components"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"High-Performance / Real-time Lists"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.strong,{children:"DX"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Easiest"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Advanced"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"useQuery$"})," when:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"You are building a real-time list (stock tickers, chat logs)."}),"\n",(0,s.jsx)(n.li,{children:"You have a heavy Dashboard component that shouldn't re-render just because one widget is loading."}),"\n",(0,s.jsx)(n.li,{children:"You want to show off 10/10 engineering skills."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453(e,n,t){t.d(n,{R:()=>a,x:()=>l});var r=t(6540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);