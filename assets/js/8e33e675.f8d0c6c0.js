"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[677],{2987(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"recipes","title":"Recipes","description":"Authentication & Refresh Tokens","source":"@site/docs/recipes.md","sourceDirName":".","slug":"/recipes","permalink":"/-braine-quantum-query/recipes","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"API Reference","permalink":"/-braine-quantum-query/api"},"next":{"title":"Migrating from RTK Query","permalink":"/-braine-quantum-query/migration"}}');var i=t(4848),a=t(8453);const r={},o="Recipes",c={},l=[{value:"Authentication &amp; Refresh Tokens",id:"authentication--refresh-tokens",level:2},{value:"Optimistic Updates",id:"optimistic-updates",level:2},{value:"Infinite Scroll UI",id:"infinite-scroll-ui",level:2},{value:"Cache Tags (Invalidation Patterns)",id:"cache-tags-invalidation-patterns",level:2},{value:"Option 1: Using Tags (Recommended)",id:"option-1-using-tags-recommended",level:3},{value:"Option 2: Hierarchical Keys",id:"option-2-hierarchical-keys",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"recipes",children:"Recipes"})}),"\n",(0,i.jsx)(n.h2,{id:"authentication--refresh-tokens",children:"Authentication & Refresh Tokens"}),"\n",(0,i.jsx)(n.p,{children:"Configure global authentication handling, including automatic token injection and seamless refresh flows on 401 errors."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { createClient } from '@braine/quantum-query';\n\nconst client = createClient({\n  baseURL: 'https://api.example.com',\n  auth: {\n    // 1. Inject Token: Called before every request\n    getToken: async () => {\n      const token = localStorage.getItem('access_token');\n      return token; // Returns string or null\n    },\n\n    // 2. Refresh Logic: Called automatically on 401 response\n    onTokenExpired: async (client) => {\n      try {\n        const refreshToken = localStorage.getItem('refresh_token');\n        if (!refreshToken) return null;\n\n        // Perform refresh using a separate fetch or client instance\n        // to avoid infinite loops if the refresh endpoint also returns 401\n        const response = await fetch('https://api.example.com/auth/refresh', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ refreshToken })\n        });\n\n        if (!response.ok) throw new Error('Refresh failed');\n\n        const data = await response.json();\n        \n        // Save new tokens\n        localStorage.setItem('access_token', data.accessToken);\n        localStorage.setItem('refresh_token', data.refreshToken);\n\n        return data.accessToken; // Return new token to retry original request\n      } catch (err) {\n        // Refresh failed - clean up and redirect\n        localStorage.clear();\n        window.location.href = '/login';\n        return null;\n      }\n    },\n\n    // 3. Auth Failed: Called if onTokenExpired returns null or fails\n    onAuthFailed: () => {\n      window.location.href = '/login';\n    }\n  }\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"optimistic-updates",children:"Optimistic Updates"}),"\n",(0,i.jsx)(n.p,{children:"Update the UI immediately before the network request finishes."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const { refetch } = useQuery({ queryKey: ['todos'], ... });\n\nconst handleAddTodo = async (newTodo) => {\n    // 1. Snapshot previous state (optional) or just write\n    queryCache.set(['todos'], (old) => [...old, newTodo]);\n\n    // 2. Perform mutation\n    await api.post('/todos', newTodo);\n\n    // 3. Revalidate to ensure server consistency\n    queryCache.invalidate(['todos']);\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"infinite-scroll-ui",children:"Infinite Scroll UI"}),"\n",(0,i.jsx)(n.p,{children:'Simple implemention with a "Load More" button.'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"```tsx\nfunction PostList() {\n    const { data, fetchNextPage, hasNextPage } = useInfiniteQuery({\n        queryKey: ['posts'],\n        queryFn: ({ pageParam }) => fetchPosts(pageParam),\n        getNextPageParam: (lastPage) => lastPage.nextCursor\n    });\n\n    if (!data) return <Skeleton />;\n\n    return (\n        <div>\n            {data.pages.map(page => (\n                page.items.map(post => <Post key={post.id} data={post} />)\n            ))}\n            <button \n                onClick={() => fetchNextPage()} \n                disabled={!hasNextPage}\n            >\n                {hasNextPage ? 'Load More' : 'No More Data'}\n            </button>\n        </div>\n    );\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"cache-tags-invalidation-patterns",children:"Cache Tags (Invalidation Patterns)"}),"\n",(0,i.jsxs)(n.p,{children:["Target groups of queries for invalidation using ",(0,i.jsx)(n.strong,{children:"Tags"})," or ",(0,i.jsx)(n.strong,{children:"Hierarchical Keys"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"option-1-using-tags-recommended",children:"Option 1: Using Tags (Recommended)"}),"\n",(0,i.jsx)(n.p,{children:"Assign tags to queries and invalidate them by tag."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// 1. Assign Tag\nuseQuery({\n    queryKey: ['user', id],\n    queryFn: fetchUser,\n    tags: ['User'] \n});\n\n// 2. Invalidate Tag\nconst mutation = useMutation({\n    mutationFn: updateUser,\n    invalidatesTags: ['User'] // Invalidates ALL queries with tag 'User'\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"option-2-hierarchical-keys",children:"Option 2: Hierarchical Keys"}),"\n",(0,i.jsx)(n.p,{children:"Use the key structure itself as a tagging system."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"['posts']"})," -> Targets ALL posts."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"['posts', 'list']"})," -> Targets only the list."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"['posts', id]"})," -> Targets specific post."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// Invalidates ['posts', 'list'], ['posts', 1], etc.\nqueryCache.invalidate(['posts']);\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>r,x:()=>o});var s=t(6540);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);